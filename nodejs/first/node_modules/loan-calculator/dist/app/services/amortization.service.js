"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var amortization_schedule_model_1 = require("../models/amortization_schedule.model");
var amortization_entry_model_1 = require("../models/amortization_entry.model");
var loan_model_1 = require("../models/loan.model");
var math_helper_1 = require("../helpers/math.helper");
/**
 * AmortizationService
 * Class used to handle all calculations for amortization
 */
var AmortizationService = /** @class */ (function () {
    function AmortizationService() {
    }
    /**
     * Method to obtain an amortizations schedule
     * @param {Loan} loan defines the loan request
     * @param {number} amortizeTerm amount of months to amortize the loan
     * @param {LowPayEntry[]} lowPayMonths months that have strictly defined payments
     * @returns {AmortizationSchedule} returns a complete amortization schedule
     */
    AmortizationService.prototype.getAmortizationSchedule = function (loan, amortizeTerm) {
        if (loan.low.length === 0) {
            return _getPayoffs(_getBaseAmortizationSchedule(loan, amortizeTerm));
        }
        else {
            return _getPayoffs(_getLowPayAmortizationSchedule(loan, amortizeTerm));
        }
    };
    AmortizationService.prototype.getAmortizationScheduleWithDefinedPayment = function (loan, amortizeTerm, monthlyPayment) {
        if (loan.low.length === 0) {
            return _getPayoffs(_getBaseAmortizationScheduleWithDefinedPayment(loan, amortizeTerm, monthlyPayment));
        }
        else {
            return _getPayoffs(_getLowPayAmortizationScheduleWithDefinedPayment(loan, amortizeTerm, monthlyPayment));
        }
    };
    return AmortizationService;
}());
exports.AmortizationService = AmortizationService;
function _getPayoffs(amortizationSchedule) {
    for (var i = 0; i < amortizationSchedule.amortizationEntries.length; i++) {
        var payoff = 0;
        for (var j = i; j < amortizationSchedule.amortizationEntries.length; j++) {
            payoff += amortizationSchedule.amortizationEntries[j].payment;
        }
        amortizationSchedule.amortizationEntries[i].payoff = payoff;
    }
    return amortizationSchedule;
}
/**
 * Method to retrieve the "perfect" amortization schedule.
 * An amortization schedule with identical payments across the entire term.
 * @param {Loan} loan defines the loan request
 * @param {number} amortizeTerm amount of months to amortize the loan
 * @returns {AmortizationSchedule} returns a complete amortization schedule
 * @private
 */
function _getBaseAmortizationSchedule(loan, amortizeTerm) {
    var amortizationSchedule = new amortization_schedule_model_1.AmortizationSchedule(loan, amortizeTerm, 0, 0, 0, []);
    var paidPrincipal = 0.0;
    var monthlyPayments = [];
    for (var i = 0; i < amortizeTerm; i++) {
        var amortizationEntry = _calculateAmortization(loan, amortizeTerm, paidPrincipal, i);
        amortizationEntry.month = i % 12;
        paidPrincipal += amortizationEntry.principal;
        amortizationSchedule.interestTotal += amortizationEntry.interest;
        amortizationSchedule.amortizationEntries.push(amortizationEntry);
        monthlyPayments.push(amortizationEntry.payment);
    }
    var lastEntry = amortizationSchedule.amortizationEntries[amortizationSchedule.amortizationEntries.length - 1];
    lastEntry.principal += lastEntry.balance;
    lastEntry.interest = lastEntry.payment - lastEntry.principal;
    lastEntry.balance = 0;
    amortizationSchedule.amortizationEntries[amortizationSchedule.amortizationEntries.length - 1] = lastEntry;
    amortizationSchedule.totalLoanCost =
        amortizationSchedule.feesTotal +
            amortizationSchedule.interestTotal +
            loan.amount;
    amortizationSchedule.monthlyPayment = math_helper_1.MathHelper.max(math_helper_1.MathHelper.mode(monthlyPayments));
    return amortizationSchedule;
}
function _getBaseAmortizationScheduleWithDefinedPayment(loan, amortizeTerm, monthlyPayment) {
    var minimumLoan = new loan_model_1.Loan(loan.amount, loan.down, loan.deferred, loan.term, 0, loan.low);
    var minimumAmortization = _getBaseAmortizationSchedule(minimumLoan, amortizeTerm);
    if (monthlyPayment <= minimumAmortization.monthlyPayment) {
        return minimumAmortization;
    }
    var amortizationSchedule = _getBaseAmortizationSchedule(loan, amortizeTerm);
    if (amortizationSchedule.monthlyPayment.toFixed(2) === monthlyPayment.toFixed(2)) {
        for (var i = 0.01; i >= 0; i -= 0.001) {
            var roundedRate = +(amortizationSchedule.loan.rate.toFixed(3)) + i;
            var newLoan = new loan_model_1.Loan(loan.amount, loan.down, loan.deferred, loan.term, roundedRate, loan.low);
            var roundedSchedule = _getBaseAmortizationSchedule(newLoan, amortizeTerm);
            if (roundedSchedule.monthlyPayment.toFixed(2) === monthlyPayment.toFixed(2)) {
                return roundedSchedule;
            }
        }
        return amortizationSchedule;
    }
    else {
        var modifier = 0;
        if (monthlyPayment > amortizationSchedule.monthlyPayment) {
            modifier = (monthlyPayment - amortizationSchedule.monthlyPayment) / 1000;
        }
        else {
            modifier = ((amortizationSchedule.monthlyPayment - monthlyPayment) / 1000) * -1;
        }
        var newLoan = new loan_model_1.Loan(loan.amount, loan.down, loan.deferred, loan.term, loan.rate + modifier, loan.low);
        return _getBaseAmortizationScheduleWithDefinedPayment(newLoan, amortizeTerm, monthlyPayment);
    }
}
/**
 * Method to retrieve an amortization schedule that contains low payment months
 * @param {Loan} loan defines the loan request
 * @param {number} amortizeTerm amount of months to amortize the loan
 * @param {LowPayEntry[]} lowPayMonths months that have strictly defined payments
 * @returns {AmortizationSchedule} returns a complete amortization schedule
 * @private
 */
function _getLowPayAmortizationSchedule(loan, amortizeTerm) {
    // Get normal amortization schedule
    var amortizationSchedule = _getBaseAmortizationSchedule(loan, amortizeTerm);
    return _calculateLowPayAmortization(amortizationSchedule, loan.low, 0);
}
function _getLowPayAmortizationScheduleWithDefinedPayment(loan, amortizeTerm, monthlyPayment) {
    var minimumLoan = new loan_model_1.Loan(loan.amount, loan.down, loan.deferred, loan.term, 0, loan.low);
    var minimumAmortization = _getLowPayAmortizationSchedule(minimumLoan, amortizeTerm);
    if (monthlyPayment <= minimumAmortization.monthlyPayment) {
        return minimumAmortization;
    }
    var amortizationSchedule = _getLowPayAmortizationSchedule(loan, amortizeTerm);
    if (amortizationSchedule.monthlyPayment.toFixed(2) === monthlyPayment.toFixed(2)) {
        for (var i = 0.01; i >= 0; i -= 0.001) {
            var roundedRate = +(amortizationSchedule.loan.rate.toFixed(3)) + i;
            var newLoan = new loan_model_1.Loan(loan.amount, loan.down, loan.deferred, loan.term, roundedRate, loan.low);
            var roundedSchedule = _getLowPayAmortizationSchedule(newLoan, amortizeTerm);
            if (roundedSchedule.monthlyPayment.toFixed(2) === monthlyPayment.toFixed(2)) {
                return roundedSchedule;
            }
        }
        return amortizationSchedule;
    }
    else {
        var modifier = 0;
        if (monthlyPayment > amortizationSchedule.monthlyPayment) {
            modifier = (monthlyPayment - amortizationSchedule.monthlyPayment) / 1000;
        }
        else {
            modifier = ((amortizationSchedule.monthlyPayment - monthlyPayment) / 1000) * -1;
        }
        var newLoan = new loan_model_1.Loan(loan.amount, loan.down, loan.deferred, loan.term, loan.rate + modifier, loan.low);
        return _getLowPayAmortizationScheduleWithDefinedPayment(newLoan, amortizeTerm, monthlyPayment);
    }
}
/**
 * Method to calculate low pay amortization, this is often used recursively to balance payments to 0 at the end of the term
 * @param {AmortizationSchedule} amortizationSchedule an input of a previously defined amortization schedule
 * @param {LowPayEntry[]} lowPayMonths months that have strictly defined payments
 * @param {number} monthlyRateModifier modifier used to manipulate base monthly payments
 * @returns {AmortizationSchedule} returns a complete amortization schedule
 * @private
 */
function _calculateLowPayAmortization(amortizationSchedule, lowPayMonths, monthlyRateModifier) {
    // Loop through, adjust low pay months, and identify the difference in cost from the edited months
    var lowPayIndices = [];
    lowPayMonths.forEach(function (entry) {
        lowPayIndices.push(entry.month);
    });
    var lowPayMonthImpact = 0;
    var totalLowPayMonths = 0;
    var paidPrincipal = 0;
    amortizationSchedule.amortizationEntries.forEach(function (entry) {
        // handle deferred payments
        // entry.interest = _calculateInterest(amortizationSchedule.loan.amount +
        // amortizationSchedule.loan.deferredInterest - amortizationSchedule.loan.down -
        // paidPrincipal, amortizationSchedule.loan.monthlyRate);
        if (entry.entry >= amortizationSchedule.loan.deferred) {
            if (lowPayIndices.indexOf(entry.month) > -1) {
                // this is a low pay month, get low pay entry
                var lowPayEntry = _getLowPayEntry(entry.month, lowPayMonths);
                // Modify amortization entry
                entry.edited = true;
                entry.payment = lowPayEntry.payment;
                entry.principal = lowPayEntry.payment - entry.interest;
                lowPayMonthImpact += entry.principal;
                totalLowPayMonths++;
            }
        }
        paidPrincipal += entry.principal;
    });
    // calculate new normal monthly payment, cycle through and assign new values
    var newWithdrawn = (amortizationSchedule.loan.amount + amortizationSchedule.loan.deferredInterest - amortizationSchedule.loan.down);
    var newMonthlyPayment = _calculateMonthlyPayment(newWithdrawn, amortizationSchedule.loan.monthlyRate, amortizationSchedule.amortizeTerm - amortizationSchedule.loan.deferred - totalLowPayMonths) + monthlyRateModifier;
    var totalPrincipalPaid = 0;
    amortizationSchedule.amortizationEntries.forEach(function (entry) {
        if (entry.entry >= amortizationSchedule.loan.deferred) {
            if (!entry.edited) {
                // calculate new principal and interest
                entry.payment = newMonthlyPayment;
            }
            entry.interest = _calculateInterest(newWithdrawn - totalPrincipalPaid, amortizationSchedule.loan.monthlyRate);
            entry.principal = entry.payment - entry.interest;
            entry.balance = (amortizationSchedule.loan.amount + amortizationSchedule.loan.deferredInterest -
                amortizationSchedule.loan.down) - (totalPrincipalPaid + entry.principal);
            totalPrincipalPaid += entry.principal;
        }
    });
    amortizationSchedule.totalLoanCost = amortizationSchedule.loan.down;
    amortizationSchedule.feesTotal = 0;
    amortizationSchedule.amortizationEntries.forEach(function (entry) {
        amortizationSchedule.totalLoanCost += entry.payment;
    });
    amortizationSchedule.interestTotal = amortizationSchedule.totalLoanCost - amortizationSchedule.loan.amount;
    amortizationSchedule.monthlyPayment = newMonthlyPayment;
    var balance = +(amortizationSchedule.amortizationEntries[amortizationSchedule.amortizationEntries.length - 1].balance.toFixed(2));
    if (balance === 0) {
        var lastEntry = amortizationSchedule.amortizationEntries[amortizationSchedule.amortizationEntries.length - 1];
        lastEntry.principal += lastEntry.balance;
        lastEntry.interest = lastEntry.payment - lastEntry.principal;
        lastEntry.balance = 0;
        amortizationSchedule.amortizationEntries[amortizationSchedule.amortizationEntries.length - 1] = lastEntry;
        return amortizationSchedule;
    }
    else {
        var balanceModifier = (Math.abs(balance) / 100) / 2;
        var modifier = 0;
        if (balance > 0) {
            modifier = monthlyRateModifier + balanceModifier;
        }
        else {
            modifier = monthlyRateModifier - balanceModifier;
        }
        return _calculateLowPayAmortization(amortizationSchedule, lowPayMonths, modifier);
    }
}
/**
 * Method to retrieve a single amortization entry (month)
 * @param {Loan} loan defines the loan request
 * @param {number} amortizeTerm amount of months to amortize the loan
 * @param {number} paidPrincipal amount of previously paid principal
 * @param {number} entry the payment in the term
 * @returns {AmortizationEntry} returns an amortization entry for a specific month
 * @private
 */
function _calculateAmortization(loan, amortizeTerm, paidPrincipal, entry) {
    var payment;
    if (entry < loan.deferred) {
        payment = 0;
    }
    else {
        var paymentTerm = amortizeTerm - loan.deferred; // term minus the deferred months
        // Interest is still accrued during deferred months; so this will need to be reflected in the loan amount
        var amountWithdrawn = loan.amount - loan.down;
        for (var i = 0; i < loan.deferred; i++) {
            // Calculate interest
            amountWithdrawn += _calculateInterest(amountWithdrawn, loan.monthlyRate);
        }
        payment = _calculateMonthlyPayment(amountWithdrawn, loan.monthlyRate, paymentTerm);
    }
    var interest = _calculateInterest(loan.amount - loan.down - paidPrincipal, loan.monthlyRate);
    var principal = payment - interest;
    var balance = (loan.amount - loan.down) - (paidPrincipal + principal);
    return new amortization_entry_model_1.AmortizationEntry(entry, interest, principal, balance, payment);
}
/**
 * Method to calculate a single monthly payment
 * @param {number} withdrawn loan amount
 * @param {number} monthlyRate monthly interest rate
 * @param {number} paymentTerm term for payments (months)
 * @returns {number} the monthly payment
 * @private
 */
function _calculateMonthlyPayment(withdrawn, monthlyRate, paymentTerm) {
    if (monthlyRate === 0) {
        return withdrawn / paymentTerm;
    }
    return withdrawn * ((monthlyRate * (Math.pow((1 + monthlyRate), paymentTerm))) / ((Math.pow((1 + monthlyRate), paymentTerm)) - 1));
}
/**
 * Method to calculate the amount of interest due
 * @param {number} principal current total principal
 * @param {number} rate monthly interest rate
 * @returns {number} the interest for a specific month
 * @private
 */
function _calculateInterest(principal, rate) {
    return principal * rate;
}
/**
 *
 * @param {number} selection request low pay entry, by month
 * @param {LowPayEntry[]} lowPayEntries all low pay entries
 * @returns {LowPayEntry} single low pay entry
 * @private
 */
function _getLowPayEntry(selection, lowPayEntries) {
    var filtered = lowPayEntries.filter(function (obj) {
        return obj.month === selection;
    });
    return filtered[0];
}
//# sourceMappingURL=amortization.service.js.map